configuration:
    connection:
        host: localhost
        database_name: ''
        user: 'root'
        password: ''
    simple:
        select:
            single_city:
                sql: "SELECT * FROM city WHERE name = :name AND country_code = :country_code"
                parameters: [name, country_code]
            entire_world:
                sql: "SELECT * FROM city"
        insert:
            insert_city:
                sql: "INSERT INTO city (name, country_code, district, population) VALUES ('Kabul', 'AFG', 'Kabol', 260000)"
            insert_user:
                sql: "INSERT INTO user (name, lastname, occupation) VALUES (:name, :lastname, :occupation)"
                parameters: [name, lastname, occupation]
            single_village:
                sql: "INSERT INTO village (name, country) VALUES (:name, :country)"
                parameters: [name, country]
        update:
            single_village:
                sql: "UPDATE village SET name = :update_name WHERE id = :id"
                parameters: [update_name, id]

        delete:
            single_village:
                sql: "DELETE FROM village WHERE id = :id"
                parameters: [id]

    scenario:
        # scenario rules:
            # - a scenario has to have at least one select statement, if rules say otherwise
            # - a scenario has to return the exact result specified in the return_result config value, if rules say otherwise
            # - a 'use' option can be used with all the statements. If insert, update or delete then 'use' statement has to be a select statement or last_insert_id from an insert
            # - a 'foreign_key' option can be use with all the statements but the foreign statement has to be an insert sql statement

            # - rules can be:
                 # - minimal_select_statement: true/false - disables or enables rule that a scenario has to have at least one select sql statement
                 # - return_entity: true/false - disables or enables rule that a scenario has to return an entity/result
                       # if set to false, return_entity has to be an empty array, for example return_entity: []
        create_database:
            atomic: true
            rules: { minimal_select_statement: false, return_entity: false }
            return_entity: []
            statements:
                create_user_info_database:
                    sql_type: database
                    sql: "CREATE DATABASE IF NOT EXISTS user_information"
                use_database:
                    sql_type: database
                    sql: "USE user_information"
                create_user_table:
                    sql_type: table
                    sql: "CREATE TABLE IF NOT EXISTS user (id INT(6) UNSIGNED AUTO_INCREMENT PRIMARY KEY, name VARCHAR(256) NOT NULL, lastname VARCHAR(256) NOT NULL, occupation VARCHAR(256) NOT NULL)"
                create_address:
                    sql_type: table
                    sql: "CREATE TABLE IF NOT EXISTS address (id INT(6) AUTO_INCREMENT PRIMARY KEY, user_id INT(6) NOT NULL, city VARCHAR(256) NOT NULL, address VARCHAR(256) NOT NULL)"
                create_village:
                    sql_type: table
                    sql: "CREATE TABLE IF NOT EXISTS village (id INT(6) AUTO_INCREMENT PRIMARY KEY, name VARCHAR(256) NOT NULL, country VARCHAR(256) NOT NULL)"
                create_city:
                    sql_type: table
                    sql: "CREATE TABLE IF NOT EXISTS city (id INT(6) AUTO_INCREMENT PRIMARY KEY, name VARCHAR(256) NOT NULL, country_code VARCHAR(256) NOT NULL, district VARCHAR(256) NOT NULL, population INT(16) NOT NULL)"

        clear_database:
            atomic: true
            rules: { minimal_select_statement: false, return_entity: false }
            return_entity: []
            statements:
                clear_users:
                    sql_type: table
                    sql: "TRUNCATE TABLE user"
                clear_address:
                    sql_type: table
                    sql: "TRUNCATE TABLE address"
                clear_village:
                    sql_type: table
                    sql: "TRUNCATE TABLE village"
                clear_city:
                    sql_type: table
                    sql: "TRUNCATE TABLE city"

        user_info_database:
            atomic: true
            return_entity: [select_user.id, "select_user.name as user_name", "select_user.lastname  as user_lastname", get_address_by_id]
            statements:
                insert_multi_users:
                    sql_type: insert
                    sql: "INSERT INTO user (name, lastname, occupation) VALUES (:name, :lastname, :occupation)"
                    parameters: [name, lastname, occupation]
                insert_user:
                    # multiple inserts cannot have a 'use' or 'foreign_key' option on them
                    sql_type: insert
                    sql: "INSERT INTO user (name, lastname, occupation) VALUES (:name, :lastname, :occupation)"
                    use:
                        statement_name: select_user
                        values: {select_user.name : name, select_user.lastname : lastname}
                    parameters: [occupation]
                select_user:
                    sql_type: select
                    sql: "SELECT * FROM user WHERE id = :id"
                    parameters: [id]
                insert_address:
                    sql_type: insert
                    sql: "INSERT INTO address (user_id, city, address) VALUES (:user_id, :city, :address)"
                    foreign_key:
                        statement_name: insert_multi_users
                        bind_to: user_id
                    parameters: [city, address]
                get_address_by_id:
                    # when using a foreign key statement, it has to take the last foreign_key if the insert statement was a multi_insert
                    sql_type: select
                    sql: "SELECT * FROM address WHERE id = :id"
                    foreign_key:
                        statement_name: insert_address
                        bind_to: id

    callable:
        validate_user:
            type: object
            name: Test\CallableService