configuration:
    connection:
        host: localhost
        database_name: ''
        user: root
        password: 'root'

    scenario:
        create_database:
            atomic: true
            rules: { return_entity: false, minimal_select_statement: false }
            return_entity: []
            statements:
                create_database:
                    sql_type: database
                    sql: "CREATE DATABASE IF NOT EXISTS company"
                use_database:
                    sql_type: database
                    sql: "USE company"
                create_users_table:
                    sql_type: table
                    sql: "CREATE TABLE IF NOT EXISTS users (id INT(6) AUTO_INCREMENT PRIMARY KEY NOT NULL, name VARCHAR(256) NOT NULL, lastname VARCHAR(256) NOT NULL)"
                create_address:
                    sql_type: table
                    sql: "CREATE TABLE IF NOT EXISTS address (id INT(6) AUTO_INCREMENT PRIMARY KEY NOT NULL, user_id INT(6) NOT NULL, city VARCHAR(256) NOT NULL, address VARCHAR(256) NOT NULL)"
                create_category:
                    sql_type: table
                    sql: "CREATE TABLE IF NOT EXISTS category (id INT(6) AUTO_INCREMENT PRIMARY KEY NOT NULL, name VARCHAR(256) NOT NULL)"
                create_product:
                    sql_type: table
                    sql: "CREATE TABLE IF NOT EXISTS product (id INT(6) AUTO_INCREMENT PRIMARY KEY NOT NULL, category_id INT(6) NOT NULL, attribute_id INT(6) NOT NULL, name VARCHAR(256) NOT NULL)"
                create_attribute:
                    sql_type: table
                    sql: "CREATE TABLE IF NOT EXISTS attribute (id INT(6) AUTO_INCREMENT PRIMARY KEY NOT NULL, name VARCHAR(256) NOT NULL)"

        # REQUIREMENTS:
        # 1. Multiple inserts on multiple insert parameters
        #    - when saving the result of inserts, every insert has to be saved under the statement name
        #    - the statement that uses the above statement as a foreign_key option should know that it is a multiple insert and take the last inserted id
        #    - the statement that uses the above statement can have an option to select from what insert to take the last inserted id
        clothes_company:
            atomic: true
            rules: { return_entity: false }
            return_entity: []
            statements:
                insert_user:
                    sql_type: insert
                    sql: "INSERT INTO users (name, lastname) VALUES (:name, :lastname)"
                    parameters: [name, lastname]
                # foreign_key option cannot have multiple parameters bound to it
                insert_address:
                    sql_type: insert
                    sql: "INSERT INTO address (user_id, city, address) VALUES (:user_id, :city, :address)"
                    foreign_key:
                        statement_name: insert_user
                        bind_to: user_id
                insert_category:
                    sql_type: insert
                    sql: "INSERT INTO category (name) VALUES (:name)"
                    parameters: [name]
